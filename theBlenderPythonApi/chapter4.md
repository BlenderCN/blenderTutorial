# 建模和渲染的主题

本章详细介绍了3D建模和渲染中的特定主题。虽然非常一般，但在我们构建更高级的工具和插件时，
这些主题在第5章和文本的其余部分中变得非常重要。读者将了解3D艺术家，
游戏开发人员和渲染软件工程师常见的许多实用程序和陷阱。有了这些知识，
读者将能够更好地满足这些专业人员在脚本和插件开发方面的需求。

## 指定一个3D模型

3D模型是复杂的数字资源，可以由许多不同的组件组成。在我们通常认为网格是构成资源形状的最重要结构的地方，
网格由面构成，其由由索引排列的顶点组成。网格可以包含法线向量或法线，可以使用顶点或面指定，具体取决于文件格式。
当我们在摘要中引用这些术语时，我们通常会讨论3D建模主题，而不是在Blender中专门定义它们。

我们开始讨论3D模型，纯粹是网格，包括顶点，索引，面和法线。
从那里，我们讨论3D模型的高级和特定功能，作为我们对网格讨论的扩展。

### 指定网格

出于本章的目的，我们认为基本网格是由其面和法向量定义的。请参阅上述组件的以下定义：

*   顶点是指定三维空间中位置的实值三元组，通常表示为(x,y,z)。由于我们讨论的原因，
通常会在指定3D网格的文件中多次指定相同的点。在3D建模中，z轴或y轴最常用于表示垂直轴。在Blender中，z轴是垂直轴。
我们将在整个文本中使用此格式。

*   指数是正整数三元组，它使用一系列顶点指定面，通常表示为(i,j,k)。给定索引为1,...,N的N个顶点的列表，
3D空间中的面可以由1,...,N中的任意三个唯一整数三元组指定。
这个概念在逻辑上非常自然地扩展到允许我们通过重用预先指定的顶点来定义网格。由于我们解释的原因，
整数的顺序对于确定面部可见的方向很重要。索引重用元组值的概念通常会扩展到其他元组，例如法线和UV。

*   面由引用三个顶点的整数三元组索引确定。根据我们的定义，我们自然会得出这样的事实：
3D空间中的三顶点面需要总共九个实值数据点。重要的是要注意3D空间中的面只能在单个方向看到。
给定旋转相机和3D空间中的单个面部，用户将进能够从单个方向观看面部。从另一个方向看，面部将显示完全透明。
这是我们将学习控制的许多3D渲染器的原生和预期行为。请注意，默认情况下，Blender不会显示此单向行为，
但在导出为其他文件格式时，Blender将不会自动控制或更正此行为。

*   法线向量是实值三元组，用于定义网格如何与场景中的灯光和摄像机进行交互。目前，我们只关注法线，
因为它们被直接分配到点而不是3D艺术家可能已经熟悉的法线贴图。顾名思义，
在假设法线矢量垂直于其正在照射的面部的情况下，场景中的相机和照明与网格相互作用。
这并不总是一个微不足道的问题，正如我们将在我们的立方体示例中看到的那样。
法线向量还会影响面部可见的方向以及面部透明的方向，如面部定义所述。

### 指定纹理

3D模型中纹理的目的是将2D图像映射到3D表面上，通常使用现有的2D艺术资源。我们用于此的坐标约定是(u,v)坐标系。
在数学的其他领域，当讨论3D表面的2D投影时，我们通常使用(u,v)坐标系来清楚地表示我们在与(x,y,z)坐标系分开的空间中工作。

纹理坐标非常直观。如果我们想在矩形表面上拉伸图像，
我们指定uv坐标列表[(0.0,0.0),(1.0,0.0),(0.0,1.0),(1.0,1.0)]来拉伸整个图像，面朝上，从左到右，
在我们正在看的表面上。这假设我们模型中的坐标1到4表示从我们的角度看表面的左下角，右下角，左下角和右上角坐标。
有关此香草纹理方案的示例，请参见图4-1。

图4-1

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-1.png?raw=true)

如果我们想要在表面上拉伸，缩小或复制图像，我们只需通过适当的因子调整uv坐标。例如，在立方体表面上将图像平铺三次，
我们输入uv坐标[(0.0),(3.0,0.0),(0.0,3.0),(3.0,3.0)]。有关平铺纹理的示例，请参见图4-2。

图4-2

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-2.png?raw=true)

在第8章之前，我们不会通过Blender的Python API使用纹理，但是当我们讨论3D模型和文件格式时，纹理的uv坐标的概念很重要。

## 常见文件格式

我们首先列出常见的文件格式并解释它们各自的优点和用途。我们在本章开头将这些格式与我们对3D对象的定义结合使用，
以进一步说明这些概念。

### Wavefront(.obj and mtl)

Wavefront几何(.obj)和材料(.mtl)规范格式协同工作以指定网格和纹理。它们的编写方式使.obj文件可以独立存在以仅指定几何。
.obj文件非常简单易懂，非常适合用作讨论3D对象形状的标准符号。

有关带有.obj格式的xy平面中的简单方形的示例，请参见清单4-1。我们将不再详细解释.mtl文件，因为它与我们对渲染概念的讨论不太相关。

清单4-1。.obj格式的简单方形。

    # Use hashes to leave comments in .obj files
    # The 'o' tag is used to name objects
    # all data following an 'o' tag is considered
    # to have this name until another name is entered o MySimpleFace
    
    # Vertices are entered with the 'v' tag as
    # space-delimited(x,y,z) tuples
    v -1.00 0.00 1.00
    v 1.00 0.00 1.00
    v -1.00 0.00 -1.00
    v 1.00 0.00 -1.00
    
    # Texture coordinate are entered with the 'vt' tag as
    # space-delimited(u,v) tuples,between 0 and 1
    vt 0.00 1.00
    vt 1.00 1.00
    vt 0.00 0.00
    vt 1.00 0.00
    
    # Normal vectors are entered with the 'vn' tag as
    # space-delimited(x,y,z) tuples,can be normal vectors if desired
    vn 0.0000 1.0000 0.0000
    
    # Indices are entered with the 'f' (for face) tag as
    # space-delimited triplets of v,vt,and vn indices as
    # f v_i/vt_i/vn_i v_j/vt_j/vn_j v_k/vt_k/vn_k
    # Faces can have any number(three or more) coplanar point
    f 2/2/1 3/3/1 1/1/1
    f 2/2/1 4/4/1 3/3/1
    
    # Alternatively,the faces section for this face can be
    # written as a single coplanar quadrilateral:
    f 1/1/1 2/2/1 4/4/1 3/3/1
    
    # Alternatively,the texture coordinates can be
    # excluded with double slashes
    f 1//1 2//1 4//1 3//1
    
我们在清单4-1中看到.obj文件格式的规范，用于具有以下特征的简单面：  

*   两个单位长两个单位宽

*   以原点为中心，法线向量沿z轴向上

*   一些纹理沿正x轴和y轴定向。

我们将在以下实例中看到.obj格式与其他格式相比相当成熟且灵活。

### STL(STereoLithography)

STL文件格式通常由工程师和CAD软件使用。与.obj格式相比，它是冗长的，但带有二进制规范以补偿其低效率。
大多数STL出口商(包括Blender)默认使用二进制规范，在没有特殊软件的帮助下使文件难以辨认。
我们只在本文中使用文件的文本格式。

有关我们的简单面，请参见清单4-2,如清单4-1所示，以STL格式指定。STL支持法线向量和面，但不使用索引或支持纹理坐标。
如清单4-2所示，我们必须指定两次相同法向量和总共六个顶点来指定STL中的四边形面。此外，STL不支持超过三个共面点的规范。
奇怪的是，在大多数3D文件格式允许将法向量分配给点的情况下，STL仅允许在面部级别上分配法向量。

结构相当不言自明。每个侧面法线x y z初始化一个面，然后每个外部loop-endloop对保持面的有序顶点。
每个顶点在循环内指定为顶点x y z。

清单4-2。STL格式的简单面(文本格式)

    solid MyFace
      facet normal    0.0     0.0     1.0
        outter loop     
          vertex     -1.0    -1.0     0.0
          vertex      1.0    -1.0     0.0
          vertex     -1.0     1.0     0.0
        endloop
      endfacet
      facet normal    0.0     0.0     1.0
        outer loop
          vertex      1.0    -1.0     0.0
          vertex      1.0     1.0     0.0
          vertex     -1.0     1.0     0.0
        endloop       
      endfacet
    endsolid Myface

### PLY(多边形文件格式）

此文件格式由斯坦福大学构建，用于处理3D扫描软件。它与C语言有着密切的关系，并且有很多开源工具可以直接使用它。
我们对3D网格格式的讨论应该开始重复。PLY格式本质上是.obj的精简版本，其中包含仅支持顶点和面的附加元数据，
而不支持法线矢量或纹理。

标题中的一些元数据是相当标准的，包括ply，格式和属性标签。我们不会深入研究属性标签。只要知道他们引用C级数据类型与现有C库合作。
元素顶点和元素面线分别指定文件的多少行引用顶点和面。在我们的例子中，我们有元素顶点4和元素面1,因为我们指定了一个面。
值得注意的是，PLY格式支持超过三个共面点的规范。

有关面部的示例，请参见清单4-3。

清单4-3。PLY格式的简单面。

    ply
    format ascii 1.0
    comment specifies a simple face
    element vertex 4
    property float32 x
    property float32 y
    property float32 z
    element face 1
    property list uint8 int32 vertex_indices
    end_header
    -1 -1 0
    1 -1 0
    1 1 0
    -1 1 0
    4 1 0 3 2
    
### Blender(.blend) Files and Interchange Formats

特别死根据前面的例子，Blender的原生文件格式和内存数据结构非常复杂。Blender支持对具有非共面顶点的顶点，
边和面进行操作。一直以来，Blender管理与纹理，声音，动画，装备，灯光等相关的复杂数据。这些.blend文件以二进制表示，
并不是人类可读的。值得庆幸的是，我们可以通过Python API安全地继续访问和操作Blender的内部数据。

.blend文件与前面提到的.obj,.stl和.ply文件之间的复杂性和完整性的差异是有意的。
虽然所有这些文件都以某种方式表示3D模型，但.blend文件并非设计为在其他3D建模套件中导出和导入。
上面讨论的文件格式称为交换格式，这意味着它们有意地表示可以在建模软件和渲染器之间轻松移植的通用且定义明确的特征子集。 

虽然开发人员过去曾尝试在3DS Max，AutoCAD和Maya以及Blender等特定3D建模套件之间创建完整的互操作性，
但它们必然无法捕获任何一个套件支持的所有功能。因此，我们采用交换格式来保持通信和期望的一致性。

## 基本对象的最小规范

重要的是讨论3D模型规范背后的一些理论，以便我们可以评估各种3D文件格式的效率和功能。
我们将参考上一节中讨论的文件格式来帮助说明。

### 立方体的定义

立方体是一个三维物体，有六个面由相等长度的正方形组成。一个立方体包含6个面，12个边和8个顶点。
立方体的正方形面可以被视为两个直角三角形的组合，其腿长等于方形长度。请注意，
3D空间中的任何对象都可以通过浮点和整数值定义，其中浮点数指定3D空间中的位置和方向，整数指定相关索引。
3D对象还需要法线矢量，可以将其分配给顶点或面。

我们将使用此信息构建详细说明不同3D规范模式的数据密度的表。

### 天真的规范

为了天真地指定3D立方体，我们将彼此独立地指定6*2=12个所需三角形面中的每一个，并为每个点指定独立的法向量。
这应该导致12*3=36个顶点和12*3=36个法向量。我们可以用.obj格式编写，如清单4-4所示。
图4-3显示了此模型的数据结构的可视化。

这个模型的天真定义如下：

*   无需重复顶点坐标。

*   无需重复的法线矢量方向。

*   不必使用顶点法线代替面法线。

清单4-4。天真定义的立方体。

    o NativeCube
    
    # (36*3) + (36*3) = 216 floats
    # (12*3) + (12*3) = 72 integers
    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -0.999999
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 1.000000
    v -1.000000 1.000000 -1.000000
    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v 1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v -1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -0.999999
    v 1.000000 1.000000 -0.999999
    v -1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 1.000000
    v 0.999999 1.000000 1.000001
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 1.000000
    v -1.000000 1.000000 1.000000
    v -1.000000 1.000000 -1.000000
    v -1.000000 1.000000 -1.000000
    v 1.000000 -1.000000 -1.000000
    v -1.000000 -1.000000 1.000000
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 -1.000000
    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v 1.000000 1.000000 -0.999999
    v -1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 1.000000
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 -1.000000
    v -1.000000 1.000000 -1.000000
    
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    
    f 9//1 17//13 13//25
    f 24//2 20//14 16//26
    f 15//3 12//15 10//27
    f 6//4 18//16 2//28
    f 3//5 23//17 14//29
    f 1//6 8//18 5//30
    f 29//7 11//19 32//31
    f 36//8 22//20 34//32
    f 31//9 19//21 30//33
    f 27//10 21//22 33//34
    f 26//11 7//23 35//35
    f 25//12 4//24 28//36
    
换句话说，天真的3D规范不会通过将每个面部视为完全独立的三角形来重复使用顶点或法线。此外，
在诸如立方体的简单情况下使用顶点法线而不是面法线会增加浪费。这种模式将从以下方面收益：

*   删除重复的顶点。

*   将三角形面指定为方形面。

*   删除重复的法线和/或使用面法线

*   正确利用索引来组织顶点和法线。

值得注意的是，这种格式与.stl格式具有相同的复杂程度，禁止STL使用面法线。

接下来我们将展示非重复顶点和法线如何在不增加复杂性的情况下缩小模型大小

### 使用索引共享顶点和法线

清单4-5显示了一个包含共享顶点和法线的.obj文件。当文件能够正确使用索引而不是重复浮点数据时，
我们只需要总共42个浮点数。在下一个示例中，我们将利用共面曲面来减少整数的总数。在视觉上，
这些数据看起来与图4-3中的相同，我们只减少了浮点数据中的重复。

清单4-5具有共享顶点和法线的立方体

    o SharingCube
    
    # (8*3) + (6*3) = 42 floats
    # (12*3) + (12*3) = 72 integers

    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -0.999999
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 1.000000
    v -1.000000 1.000000 -1.000000    

    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 -0.0000 0.0000
    vn 0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000

    f 1//1 3//1 4//1
    f 8//2 6//2 5//2
    f 5//3 2//3 1//3
    f 6//4 3//4 2//4
    f 3//5 8//5 4//5
    f 1//6 8//6 5//6
    f 1//1 2//1 3//1
    f 8//2 7//2 6//2
    f 5//3 6//3 2//3
    f 6//4 7//4 3//4
    f 3//5 7//5 8//5
    f 1//6 4//6 8//5

图4-3

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-3.png?raw=true) 

### 使用共面顶点减少面数

清单4-6显示了一个.obj文件，其中多维数据集的每个面都是整体指定的。因为我们知道立方体的面是所有共面点的集合，
所以我们可以将它们指定为单个面。虽然渲染器仍将立方体解释为三角形面的集合，
但.obj文件格式允许我们使用共面顶点指定N维曲面。图4-4显示了此数据结构的可视化表示。

清单4-6具有共面表面的立方体作为单面。

    o CoplanarFaceCube
    
    # (8*3) + (6*3) = 42 floats
    # (6*4) + (6*4) = 48 integers
    v -1.000000 -1.000000 1.000000
    v -1.000000 1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v -1.000000 1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v 1.000000 1.000000 1.000000
    v 1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -1.000000
    
    vn -1.0000 0.0000 0.0000
    vn 0.0000 0.0000 -1.0000
    vn 1.0000 0.0000 0.0000
    vn 0.0000 0.0000 1.0000
    vn 0.0000 -1.0000 0.0000
    vn  0.0000 1.0000 0.0000
    
    f 1//1 2//1 4//1 3//1
    f 3//2 4//2 8//2 7//2
    f 7//3 8//3 6//3 5//3
    f 5//4 6//4 2//4 1//4
    f 3//5 7//5 5//5 1//5
    f 8//6 4//6 2//6 6//6

图4-4

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-4.png?raw=true) 

这里没有太多的重复观察。最后的重复特征是在每个面的每个点处指定法向矢量索引。我们提出了一个使用面顶点的理论.obj文件。

### 使用面顶点简化指数

清单4-7显示了一个理论上的.obj文件，其中多维数据集的每个面都分配给相同的法线。因为立方体具有明确定义的面法线，
所以我们很容易在数据结构中指定它们。通常在.obj文件中，我们会重复指定顶点法线的索引。然后，
渲染过程将计算顶点法线的合成以确定如何遮蔽相关面部。在这个理论上的.obj文件中，我们将在面级别而不是点级别指定索引。
该文件被称为理论，因为.obj文件实际上不支持面法线，尽管其他常见的文件格式也是如此。为了保持一致性，
我们将继续在此示例中使用.obj格式，但请注意此文件未导入。有关数据结构的直观表示，请参见图4-5。

图4-5
![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-5.png?raw=true)

下一次迭代将通过将多维数据集二进制化到渲染器本身来降低复杂性。这是一种特殊情况，仅适用于非常常见和简单的形状。
开发人员很少能够在渲染器本身中自定义此功能，但值得注意。

清单4-7。面部法线的立方体。

    o FaceNormal .obj format,not valid
    
    # Theoretical .obj format,not valid
    # (8 * 3) + (6 * 3) = 42 floats
    # (6 * 4) + (6 * 1) = 30 integers
    
    v -1.000000 -1.000000 1.000000
    v -1.000000 1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v -1.000000 1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v 1.000000 1.000000 1.000000
    v 1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -1.000000 
    
    vn -1.0000 0.0000 0.0000
    vn 0.0000 0.0000 -1.0000
    vn 1.0000 0.0000 0.0000
    vn 0.0000 0.0000 1.0000
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    
    # Face and normals defined as:
    # f (v_1, v_2, v_3, v_4)//n_1
    f (1 2 4 3)//1
    f (3 4 8 7)//2
    f (7 8 6 5)//3
    f (5 6 2 1)//4
    f (3 7 5 1)//5
    f (8 4 2 6)//6
    
### 将立方体表示为原始

基元松散地指代预先构建到3D软件包中的非常常见的对象。最值得注意的是，对于此讨论，渲染器中的基元是最常见对象的二进制化版本，
在加载时间内总是优于等效文本文件规范(.obj,.stl等）。如果可能，请查看渲染器的文档，
以查找使用渲染器的默认基元添加简单对象(通常是立方体，球体，圆柱体，圆锥体和圆环体)的机会。
这并不是说对象的内存规范在空间上比其他任何规范更有效，而只是说它们具有已经二进制化的优点。

### 概要

我们讨论了四种顺序更有效的指定多维数据集的方法，最后选择使用了使用原语。有关结果的摘要，请参见下表。
我们通过命令行工具确定了.obj文件的大小。我们使用以下事实估计了对象的内存大小：在32位系统中，
C++中的浮点数和整数是四个字节。内存大小的百分比变化在每个步骤都足够大，以证明进行任何这些效率调整的合理性。

    ———————————————————————————————————————————————————————————————————————————————————————————————————————
    Method                  No.Floats    No.Integers     .obj Size(KB)     In-Memory Size(KB)    In-Mem%∆
    ———————————————————————————————————————————————————————————————————————————————————————————————————————
    Naive                   216          72               2.28             1.15                  0%
    Add Triplet Sharing     42           72               0.61
    Use Coplanar Surfaces   42           48               0.54             0.36                  22%
    Use Face Normals        42           30               0.50             0.29                  20%
    ———————————————————————————————————————————————————————————————————————————————————————————————————————
    
三元组共享的内存比变化是一个令人信服的理由，只要有可能，总是支持.obj和.pl超过.stl。
熟悉本节中讨论的信息对于Blender Python API开发人员至关重要。虽然Blender非常强大，
但却让我们有机会既浪费又高效。

## 程序生成中的常见错误

我们使用本章中建立的语言来说明程序生成的模型的一些常见问题以及调试它们的步骤。

### 同心法线

在生成模型并导出为各种交换和渲染格式时，法向量很容易被忽略或错误分配。Blender在3D视窗中为我们处理大部分法向量管理过程，
因此这些问题很少在出口前发现。我们遇到的一个非常常见的错误是无法解释的不稳定照明。这个问题通常归结为正常管理，
可以通过Blender本身的一些函数调用或按钮点击来解决。

有关立方体的.obj文件的示例，请参见清单4-8,该文件未正确地给出了同心法线。有关使用平面法线正确导出的立方体的示例，
请参见4-9。这些立方体均在WebGL中呈现，以显示法线在导出到其它渲染器时如何影响光照。有关同心和平面立方体模型的渲染，
请参见图4-6和4-7。

同心立方体被照亮和遮蔽，就好像它是一个球体，而平面立方体在逻辑上被点亮和遮蔽，将顶面视为一种桌面。
通过清单4-8,我们看到立方体中的每个顶点都匹配一个法线向量，该法向量等于由1/√3 ≈ 0.5773缩放的顶点。这在某些导出器中是危险行为，
如果未找到显式正常信息，则默认情况下将从缩放顶点创建单位向量。这可以防止导出器出现故障，但会导致光线不足且通常无法识别的对象。

这个问题对于通常使用大平面表面的硬表面建模器来说是常见的。对于创建高多边形模型的有机模型的有机建模器，这个问题可能更容易被诊断出来。

清单4-8。具有同心法线的立方体。

    o ConcentricCube
    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -0.999999
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 1.000000
    v -1.000000 1.000000 -1.000000
    
    vn 0.5773503 -0.5773503 -0.5773503
    vn 0.5773503 -0.5773503 0.5773503
    vn -0.5773503 -0.5773503 0.5773503
    vn -0.5773503 -0.5773503 -0.5773503
    vn 0.5773503 0.5773503 -0.5773497
    vn 0.5773497 0.5773503 0.5773508
    vn -0.5773503 0.5773503 0.5773503
    vn -0.5773503 0.5773503 -0.5773503
    
    f 1//1 3//3 4//4
    f 8//8 6//6 5//5
    f 5//5 2//2 1//1
    f 6//6 3//3 2//2
    f 3//3 8//8 4//4
    f 1//1 8//8 5//5
    f 1//1 2//2 3//3
    f 8//8 7//7 6//6
    f 5//5 6//6 2//2
    f 6//6 7//7 3//3
    f 3//3 7//7 8//8
    f 1//1 4//4 8//8
    
清单4-9。具有平面法线的立方体。

    o PlanarCube
    v 1.000000 -1.000000 -1.000000
    v 1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 1.000000
    v -1.000000 -1.000000 -1.000000
    v 1.000000 1.000000 -0.999999
    v 0.999999 1.000000 1.000001
    v -1.000000 1.000000 1.000000
    v -1.000000 1.000000 -1.000000
    
    vn 0.0000 -1.0000 0.0000
    vn 0.0000 1.0000 0.0000
    vn 1.0000 0.0000 0.0000
    vn -0.0000 -0.0000 1.0000
    vn -1.0000 -0.0000 -0.0000
    vn 0.0000 0.0000 -1.0000
    
    f 1//1 2//1 3//1 4//1
    f 5//2 8//2 7//2 6//2
    f 1//3 5//3 6//3 2//3
    f 2//4 6//4 7//4 3//4
    f 3//5 7//5 8//5 4//5
    f 5//6 1//6 4//6 8//6

图4-6

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-6.png?raw=true) 

图4-7

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-7.png?raw=true)

这个问题可以通过几种方式解决，具体取决于具体的出口商。在许多情况下，目标文件格式不支持面级法线或面法线，
因此我们必须强制Blender处理顶点法线或定点法线。在这种情况下，我们让Blender为每个顶点创建多个实例，
以便它可以为每个顶点分配一个单独的法线。在我们的立方体实例中，立方体的每个顶点都连接到三个单独的面，
因此需要三个单独的顶点法线。

我们可以使用Edge Split修改器来完成此任务。可以在Properties>Modifiers>Add Modifier>Edge Split中找到此属性。
根据您的喜好调整分割阈值，然后选择应用。有关访问此修饰符的Blender Python方法，请参阅清单4-10。
这可以很容易地包含在一个函数中，并且很适合前面章节中建立的ut.sel函数类。

清单4-10。具有平面法线的立方体。

    # Add modifier to selected objects
    bpy.ops.object.modifier_add(type='EDGE_SPLIT')
    
    # Set split threshold in radians
    bpy.context.object.modifiers['EdgeSplit'].split_angle = (3.1415/180) * 5
    
    # Apply modifier
    bpy.ops.object.modifier_apply(apply_as='DATA',modifier='EdgeSplit')

结果显示非常有效。图4-8和4-9显示了在Blender中观察到的法线向量之前和之后。

图4-8

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-8.png?raw=true)

图4-9

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-9.png?raw=true)

### 翻转法线

另一个常见问题是无意中翻转法线。由于Blender的3D视窗的某些行为，这个问题可以潜移默化Blender Python程序员。
如前所述，翻转法线可以使平面看起来透明。这通常很难在Blender中诊断，因为Blender在3D视窗中将所有平面都视为双面。
这不是直观的，因为为了性能和一致性，常见的渲染器将平面视为片面的。

在图4-8和4-9中，我们绘制了法线向量以显示它们指向的方向。在这两个图中，法线明显指向物体外部，
因此在出口时没有遇到翻转法线的危险。图4-10和4-11显示了在WebGL中呈现的立方体的两个透视图，其中单个面上具有翻转法线。
正如我们在这些图中所看到的那样，具有翻转法线的面是透明的，我们期望在其后面看到的面也是透明的，
因为我们正在从后面观察它们。在数学上，这可以通过将每个翻转的法向量按-1来缩小来解决。在Blender中，
通过进入‘编辑模式’并导航到Tool Shelf>Shading/UVs>Shading>Normals>Flip Direction,
可以非常轻松地执行此操作。此按钮将根据所选零件翻转所有选定，顶点，边或面的法线。

图4-10

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-10.png?raw=true)

图4-11

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-11.png?raw=true)

在Blender的Python API中，我们可以通过在编辑模式下调用bpy.ops.mesh.flip_normals()来执行相同的功能，
并选择对象的某些部分。复杂的程序生成通常会产生定向不良的法线，可以使用此函数在后代修正。

Tool Shelf>Shading/UVs>Shading>Normals>Recalculate命令，调用bpy.ops.mesh.normals_make_consistent()，
将告诉Blender尽可能重新计算明确定义的对象的法线。这对每个对象都表现不佳，但仍然有用。

### Z-Fighting

Z-fighting是一种常见的渲染问题，它会产生毛刺的对象而不会抛出错误或使渲染器崩溃。大多数动画师和游戏玩家都熟悉这个问题，
无论他们是否听过这个术语。有关在渲染视图中Blender四个立方体之间的Z-fighting的示例，请参见图4-12.

图4-12

![](https://github.com/BlenderCN/blenderTutorial/blob/master/mDrivEngine/4-12.png?raw=true)

要理解Z-fighting发生的原因，我们必须了解深度缓冲区在渲染器中的作用。在几乎每种情况下，
渲染对象所涉及的计算都发生在具有非常标准化的图形API(例如，OpenGL和DirectX)的图形处理单元(GPU)上。
这些渲染API中的标准协议是使用相机对于网格的位置来确定哪些对象对用户可见和不可见。该信息存储在深度缓冲区中。
在屏幕上显示2D图像之前，深度缓冲区告诉渲染器哪个网格像素最接近相机，因此对用户可见。

鉴于此信息，为什么深度缓冲区不支持一个网格而不是另一个网格以防止出现混乱的Z-fighting效应？深度缓冲区存储高精度浮点值，
渲染器不进行调整以评估浮点数的相等性。驱动图形API的低级语言通过进行简单的浮点数比较来保持效率。出于同样的原因，
在Python中，0.1*0.1>0.01返回True，浮点数比较在渲染器中表现不一致。与浮点运算相关的问题在计算机科学中得到了很好研究，
浮点平等是其最重要的挑战之一。

考虑到Blender及其Python API中的工具，如何解决这个问题？根据具体情况，有许多解决方案。

*   将每个物体平移一个小而不明显的量(约0.000001个Blender单位)，使得表面不再是共面的。如果平移无效，请尝试将其平移稍微大一点。

*   在编辑模式下删除内部面。

*   重新生成算法以生成非重叠的表面。

*   在编辑模式下使用溶解和限制溶解工具。

最终，有许多方法可以处理Z-fighting,这些方法都可以确保模型中不再存在共面曲面。我们不要详细说明所有可能的方法。

## 结论

重要的是要记住，Blender已经从这里讨论的许多低级3D建模概念中抽象出来。对我们有帮助的是，我们不必担心数据表示，
着色语义和绝大部分时间的Z-fighting。尽管如此，我们还是会介绍这些概念，但在调试时，
对这些问题及其驱动程序的了解可以避免很多麻烦。
